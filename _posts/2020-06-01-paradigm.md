---
layout:     post                    
title:     	范式的概念										
subtitle:   范式的概念，表设计原理
date:       2020-06-01           
author:     Qiyibaba               
header-img: img/post-bg-202003.jpg   
catalog: true                     
tags:                               
    - database
    - 范式

---

## 范式的概念

教材定义：是什么意思。按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度

粗略理解：**一张数据表的表结构所符合的某种设计标准的级别**

数据库范式：1NF，2NF，3NF，BCNF，4NF，5NF，符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF

> “关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。

### 第一范式（1NF）

1NF的定义为：符合1NF的关系中的每个属性都不可再分。下表1就不满足第一范式，直观的理解就是，满足第一范式的行使用的都是基础数据类型，不存在复杂类型

```
------------------------------------------------------------
|        |       |      IN      |      OUT     |           |
| NUMBER | NAME  |--------------|--------------|   EXTRA   |
|        |       | SUM | PRICE  | SUM | PRICE  |           |
------------------------------------------------------------
|        |       |     |        |     |        |           |
------------------------------------------------------------
```

1NF是所有关系型数据库的最基本要求，你在关系型数据库管理系统（RDBMS）中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。如果我们要在RDBMS中表现表中的数据，就得设计为下表2的形式：

```
-----------------------------------------------------------------------------
| NUMBER | NAME  | IN SUM | IN PRICE  | OUT SUM | OUT PRICE  |     EXTRA    |
-----------------------------------------------------------------------------
|        |       |        |           |         |            |              |
-----------------------------------------------------------------------------
```

但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如对于下表3中的设计（数据长度8*6=48）：

```
-----------------------------------------------------------------------------
| id        |    姓名     |        系名 |     系主任    |            课名 | 分数|
-----------------------------------------------------------------------------
| 1001      |    李晓明   |   经济系     |    王强       |  高等数学       | 90 |
| 1001      |    李晓明   |   经济系     |    王强       |  大学英语       | 87 | 
| 1001      |    李晓明   |   经济系     |    王强       |  普通化学       | 76 | 
| 1002      |    张莉莉   |   经济系     |    王强       |  高等数学       | 90 | 
| 1002      |    张莉莉   |   经济系     |    王强       |  高等数学       | 82 | 
| 1002      |    张莉莉   |   经济系     |    王强       |  高等数学       | 96 | 
| 1003      |    高晓松   |   法律系     |    刘能       |  法学基础       | 88 | 
| 1003      |    高晓松   |   法律系     |    刘能       |  高等数学       | 90 | 
-----------------------------------------------------------------------------
```

表中存在的问题

1. 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——**数据冗余过大** 

2. 假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——**插入异常**

   注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。

   注２：**码：关系中的某个属性或者某几个属性的组合，用于区分每个元组**（可以把“元组”理解为一张表中的每条记录，也就是每一行）**。**

3. 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——**删除异常**

4. 假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——**修改异常**。

正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。

### 第二范式（2NF）

其改进是，**2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖**。接下来对这句话中涉及到的四个概念——**“函数依赖”**、**“码”**、**“非主属性”**、与**“部分函数依赖”**进行一下解释。

#### 函数依赖

**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y**。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。

```
对上表中，找不到任何一条记录，它们的学号相同而对应的姓名不同，所以可以说姓名依赖于学号（学号→姓名），反过来，姓名相同，不一定学号相同，可能存在同名的情况下，所以学号函数依赖于姓名。可以把符号”a→b“解释为，可以通过唯一的a得到唯一的b，其他的依赖关系还有：
系名 → 系主任
学号 → 系主任
学号，课名 → 分数
不成立的依赖关系：
学号 → 课名，一个学号的学生可以报多个课
学号 → 分数，同上，不同课有不同分析
课名 → 系主任，不同专业也有同样的课名，不能确认系主任
学号，课名 → 姓名，这个不对吧？？
```

#### 完全函数依赖

在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X **完全函数依赖**

```
		F                       F
X   →   Y  ，如 (学号，课名)  →   分数,同一个的学号对应的分数不确定，同一个课名对应的分数也不确定
说明：如果X只有一个属性，并且符合函数依赖，肯定属于完全函数依赖
```

#### 部分函数依赖

假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X  P→ Y

```
		P                       P
X   →   Y  ，如 (学号，课名)  →   姓名
说明：可以这么理解，如果y完全函数依赖x，则y部分函数依赖于任何一个包含x的集合
```

#### 传递函数依赖

假如 Z 函数依赖于 Y，且 Y 函数依赖于 X，Y 不包含于 X，且 X 不函数依赖于 Y这个前提，那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z

#### 码

设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为**候选码**，简称为**码**。在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为**主码**） 

例如：对于表3，**（学号、课名）**这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）

#### 非主属性

包含在任何一个码中的属性成为主属性。

例如：对于表3，主属性就有两个，**学号** 与 **课名**。

终于可以回过来看2NF了。首先，我们需要判断，表3是否符合2NF的要求？根据2NF的定义，判断的依据实际上就是看数据表中**是否存在非主属性对于码的部分函数依赖**。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是：

```
第一步：找出数据表中所有的码。
第二步：根据第一步所得到的码，找出所有的主属性。
第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。
第四步：查看是否存在非主属性对码的部分函数依赖。
```

#### 判断是否符合第二范式

##### 第一步

1. 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。
2. 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。
3. ……
4. 查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。

看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“**完全**函数依赖”），见部分函数依赖的解释。

```
【  学号   课名   】     →       分数
    ↙    ↓    ↘
 姓名    系名 → 系主任
```

这一步完成以后，可以得到，表3的码只有一个，就是**（学号、课名）**。

##### 第二步

主属性有两个：**学号** 与 **课名**

##### 第三步

非主属性有四个：**姓名**、**系名**、**系主任**、**分数**

##### 第四步

对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 系**名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性  对码**（学号，课名）**的部分函数依赖。

所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。为了让表3符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。模式分解的方法不是唯一的，以下是其中一种方法：
选课（学号，课名，分数）
学生（学号，姓名，系名，系主任）

我们先来判断以下，**选课**表与**学生**表，是否符合了2NF的要求？

对于**选课**表，其码是**（学号，课名）**，主属性是**学号**和**课名**，非主属性是**分数**，**学号**确定，并不能唯一确定**分数**，**课名**确定，也不能唯一确定**分数**，所以不存在非主属性**分数**对于码 **（学号，课名）**的部分函数依赖，所以此表符合2NF的要求。

对于**学生**表，其码是**学号，**主属性是**学号**，非主属性是**姓名、系名**和**系主任**，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。

```
选课表：【  学号   课名   】     →       分数
  
学生表： 姓名    系名 → 系主任
            ↖   ↑   ↗
               学号
```

表4表示了模式分解以后新的数据，（数据长度8\*3+4\*3=36）,比1NF时数据量小：

```
------------------------------------
| id         |           课名 | 分数|
------------------------------------
| 1001       |  高等数学       | 90 |
| 1001       |  大学英语       | 87 | 
| 1001       |  普通化学       | 76 | 
| 1002       |  高等数学       | 90 | 
| 1002       |  高等数学       | 82 | 
| 1002       |  高等数学       | 96 | 
| 1003       |  法学基础       | 88 | 
| 1003       |  高等数学       | 90 | 
------------------------------------

-------------------------------------------------------
| id        |    姓名     |        系名 |     系主任    |
-------------------------------------------------------
| 1001      |    李晓明   |   经济系     |    王强       |
| 1002      |    张莉莉   |   经济系     |    王强       |
| 1003      |    高晓松   |   法律系     |    刘能       | 
-------------------------------------------------------
```

现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？

1. 李小明转系到法律系，只需要修改一次李小明对应的系的值即可。——有改进
2. 数据冗余是否减少了？学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进
3. 删除某个系中所有的学生记录，该系的信息仍然全部丢失。——无改进
4. 插入一个尚无学生的新系的信息，因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进

所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性**系主任**对于码**学号**的传递函数依赖。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。

### 第三范式（3NF）

**第三范式（3NF）** **3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖**。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。

接下来我们看看表4中的设计，是否符合3NF的要求。

对于**选课**表，主码为（学号，课名），主属性为**学号**和**课名，**非主属性只有一个，为分数，不可能存在传递函数依赖，所以**选课**表的设计，符合3NF的要求。

对于**学生**表，主码为**学号**，主属性为**学号**，非主属性为**姓名**、**系名**和**系主任**。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性**系主任**对于码**学号**的传递函数依赖，所以**学生**表的设计，不符合3NF的要求。

为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：
选课（学号，课名，分数）
学生（学号，姓名，系名）
系（系名，系主任）

对于**选课**表，符合3NF的要求，之前已经分析过了。

对于**学生**表，码为**学号**，主属性为**学号**，非主属性为**系名**，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。

对于**系**表，码为**系名**，主属性为**系名**，非主属性为**系主任**，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。。

```
选课表：【  学号   课名   】     →       分数
  
学生表： 姓名    系名
            ↖   ↑ 
               学号
               
系表：   系名 → 系主任
```

新的数据表：

```
------------------------------------
| id         |           课名 | 分数|
------------------------------------
| 1001       |  高等数学       | 90 |
| 1001       |  大学英语       | 87 | 
| 1001       |  普通化学       | 76 | 
| 1002       |  高等数学       | 90 | 
| 1002       |  高等数学       | 82 | 
| 1002       |  高等数学       | 96 | 
| 1003       |  法学基础       | 88 | 
| 1003       |  高等数学       | 90 | 
------------------------------------

---------------------------------------
| id        |    姓名     |       系名 |
---------------------------------------
| 1001      |    李晓明   |   经济系    |
| 1002      |    张莉莉   |   经济系    |
| 1003      |    高晓松   |   法律系    | 
---------------------------------------

-----------------------------
|        系名 |     系主任    |
-----------------------------
|   经济系     |    王强      |
|   法律系     |    刘能      |
-----------------------------
```

现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？

1. 删除某个系中所有的学生记录，该系的信息不会丢失。——有改进
2. 插入一个尚无学生的新系的信息，因为系表与学生表目前是独立的两张表，所以不影响。——有改进
3. 数据冗余更加少了。——有改进

### 结论【重要】

由此可见，符合3NF要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。

```
1NF(满足字段唯一)  → 2NF（去除部分依赖） → 2NF（去除传递依赖）
```

### 附：BCNF范式

要了解 BCNF 范式，那么先看这样一个问题：

1. 某公司有若干个仓库；
2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。

那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？

答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
码：（管理员，物品名），（仓库名，物品名）
主属性：仓库名、管理员、物品名
非主属性：数量
∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。

基于此关系模式的关系（具体的数据）可能如图所示：

```
-------------------------------------------------------
| 仓库名      |    管理员   |   物品名    |     数量      |
-------------------------------------------------------
| 上海仓      |    李晓明   |   苹果5     |    30        |
| 上海仓      |    李晓明   |   苹果6     |    20        |
| 北京仓      |    高晓松   |   苹果5     |    50        | 
-------------------------------------------------------
```

好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：

1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。
3. 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。

造成此问题的原因：存在着**主属性**对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。

解决办法就是要在 3NF 的基础上消除**主属性**对于码的部分与传递函数依赖。

仓库（仓库名，管理员）
库存（仓库名，物品名，数量）

这样，之前的插入异常，修改异常与删除异常的问题就被解决了。

以上就是关于 BCNF 的解释。

### 问题FAQ

老师您好，我看了您关于数据库范式的回答，有一点不太理解，就是关于码的定义，如果除K之外的所有属性都完全函数依赖于K时才能称K为码，那么在判断2NF时又怎么会存在非主属性对码的部分函数依赖这种情况？希望老师有时间能指点一下，谢谢

我 ：在“码”的定义中，除 K 之外的所有属性应该看成是一个集合 U（也就是一个整体），也就是说，只有 K 能够完全函数决定 U 中的每一个属性，那么 K 才是码。如果 K 只是能够完全函数决定 U 中的一部分属性，而不能完全函数决定另外一部分属性，那么 K 不是码。

比如有关系模式 R (Sno, Sname, Cno, Cname, Sdept, Sloc, Grade)，其中函数依赖集为 F= {
Sno → Sname, Sno → Sdept, Sdept → Sloc，Sno → Sloc, Cno → Cname, (Sno, Cno) → Grade }

那么 R 中的码只能是 (Sno, Cno)，Sno 或 Cno 并不能完全函数决定除 Sno / Cno 之外的所有其他属性（其实就是不能决定 Grade )，所以单独的 Sno 与 Cno 并不能作为码。

所以可得到主属性：Sno, Cno
非主属性：Sname, Cname, Sdept, Sloc, Grade

R 中存在非主属性 Cname 对于码 (Sno, Cno) 的部分函数依赖 (Cno → Cname) 。（还有很多别的例子就不一一列举了）。所以 R 不符合 2NF 的要求。



###搬运自知乎如何解释关系数据库的第一第二第三范式？https://www.zhihu.com/question/24696366/answer/29189700
###摘选刘慰的回答，感谢作者
